// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_INCLUDED_messages_2eproto
#define PROTOBUF_INCLUDED_messages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2eproto 

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2eproto
namespace ns3opengym {
class BoxSpace;
class BoxSpaceDefaultTypeInternal;
extern BoxSpaceDefaultTypeInternal _BoxSpace_default_instance_;
class DiscreteSpace;
class DiscreteSpaceDefaultTypeInternal;
extern DiscreteSpaceDefaultTypeInternal _DiscreteSpace_default_instance_;
class GetActionSpaceRequest;
class GetActionSpaceRequestDefaultTypeInternal;
extern GetActionSpaceRequestDefaultTypeInternal _GetActionSpaceRequest_default_instance_;
class GetIsGameOverReply;
class GetIsGameOverReplyDefaultTypeInternal;
extern GetIsGameOverReplyDefaultTypeInternal _GetIsGameOverReply_default_instance_;
class GetIsGameOverRequest;
class GetIsGameOverRequestDefaultTypeInternal;
extern GetIsGameOverRequestDefaultTypeInternal _GetIsGameOverRequest_default_instance_;
class GetObservationReply;
class GetObservationReplyDefaultTypeInternal;
extern GetObservationReplyDefaultTypeInternal _GetObservationReply_default_instance_;
class GetObservationRequest;
class GetObservationRequestDefaultTypeInternal;
extern GetObservationRequestDefaultTypeInternal _GetObservationRequest_default_instance_;
class GetObservationSpaceRequest;
class GetObservationSpaceRequestDefaultTypeInternal;
extern GetObservationSpaceRequestDefaultTypeInternal _GetObservationSpaceRequest_default_instance_;
class GetRewardReply;
class GetRewardReplyDefaultTypeInternal;
extern GetRewardReplyDefaultTypeInternal _GetRewardReply_default_instance_;
class GetRewardRequest;
class GetRewardRequestDefaultTypeInternal;
extern GetRewardRequestDefaultTypeInternal _GetRewardRequest_default_instance_;
class GetSpaceReply;
class GetSpaceReplyDefaultTypeInternal;
extern GetSpaceReplyDefaultTypeInternal _GetSpaceReply_default_instance_;
class InitializeReply;
class InitializeReplyDefaultTypeInternal;
extern InitializeReplyDefaultTypeInternal _InitializeReply_default_instance_;
class InitializeRequest;
class InitializeRequestDefaultTypeInternal;
extern InitializeRequestDefaultTypeInternal _InitializeRequest_default_instance_;
class ReplyMsg;
class ReplyMsgDefaultTypeInternal;
extern ReplyMsgDefaultTypeInternal _ReplyMsg_default_instance_;
class RequestMsg;
class RequestMsgDefaultTypeInternal;
extern RequestMsgDefaultTypeInternal _RequestMsg_default_instance_;
class SetActionReply;
class SetActionReplyDefaultTypeInternal;
extern SetActionReplyDefaultTypeInternal _SetActionReply_default_instance_;
class SetActionRequest;
class SetActionRequestDefaultTypeInternal;
extern SetActionRequestDefaultTypeInternal _SetActionRequest_default_instance_;
}  // namespace ns3opengym
namespace google {
namespace protobuf {
template<> ::ns3opengym::BoxSpace* Arena::CreateMaybeMessage<::ns3opengym::BoxSpace>(Arena*);
template<> ::ns3opengym::DiscreteSpace* Arena::CreateMaybeMessage<::ns3opengym::DiscreteSpace>(Arena*);
template<> ::ns3opengym::GetActionSpaceRequest* Arena::CreateMaybeMessage<::ns3opengym::GetActionSpaceRequest>(Arena*);
template<> ::ns3opengym::GetIsGameOverReply* Arena::CreateMaybeMessage<::ns3opengym::GetIsGameOverReply>(Arena*);
template<> ::ns3opengym::GetIsGameOverRequest* Arena::CreateMaybeMessage<::ns3opengym::GetIsGameOverRequest>(Arena*);
template<> ::ns3opengym::GetObservationReply* Arena::CreateMaybeMessage<::ns3opengym::GetObservationReply>(Arena*);
template<> ::ns3opengym::GetObservationRequest* Arena::CreateMaybeMessage<::ns3opengym::GetObservationRequest>(Arena*);
template<> ::ns3opengym::GetObservationSpaceRequest* Arena::CreateMaybeMessage<::ns3opengym::GetObservationSpaceRequest>(Arena*);
template<> ::ns3opengym::GetRewardReply* Arena::CreateMaybeMessage<::ns3opengym::GetRewardReply>(Arena*);
template<> ::ns3opengym::GetRewardRequest* Arena::CreateMaybeMessage<::ns3opengym::GetRewardRequest>(Arena*);
template<> ::ns3opengym::GetSpaceReply* Arena::CreateMaybeMessage<::ns3opengym::GetSpaceReply>(Arena*);
template<> ::ns3opengym::InitializeReply* Arena::CreateMaybeMessage<::ns3opengym::InitializeReply>(Arena*);
template<> ::ns3opengym::InitializeRequest* Arena::CreateMaybeMessage<::ns3opengym::InitializeRequest>(Arena*);
template<> ::ns3opengym::ReplyMsg* Arena::CreateMaybeMessage<::ns3opengym::ReplyMsg>(Arena*);
template<> ::ns3opengym::RequestMsg* Arena::CreateMaybeMessage<::ns3opengym::RequestMsg>(Arena*);
template<> ::ns3opengym::SetActionReply* Arena::CreateMaybeMessage<::ns3opengym::SetActionReply>(Arena*);
template<> ::ns3opengym::SetActionRequest* Arena::CreateMaybeMessage<::ns3opengym::SetActionRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ns3opengym {

enum MsgType {
  Unknown = 0,
  Init = 1,
  ActionSpace = 2,
  ObservationSpace = 3,
  IsGameOver = 4,
  Observation = 5,
  Reward = 6,
  Action = 7,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = Unknown;
const MsgType MsgType_MAX = Action;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum SpaceType {
  Discrete = 0,
  Box = 1,
  SpaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SpaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SpaceType_IsValid(int value);
const SpaceType SpaceType_MIN = Discrete;
const SpaceType SpaceType_MAX = Box;
const int SpaceType_ARRAYSIZE = SpaceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpaceType_descriptor();
inline const ::std::string& SpaceType_Name(SpaceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpaceType_descriptor(), value);
}
inline bool SpaceType_Parse(
    const ::std::string& name, SpaceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpaceType>(
    SpaceType_descriptor(), name, value);
}
enum Dtype {
  INT = 0,
  UINT = 1,
  FLOAT = 2,
  DOUBLE = 3,
  Dtype_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Dtype_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Dtype_IsValid(int value);
const Dtype Dtype_MIN = INT;
const Dtype Dtype_MAX = DOUBLE;
const int Dtype_ARRAYSIZE = Dtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* Dtype_descriptor();
inline const ::std::string& Dtype_Name(Dtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    Dtype_descriptor(), value);
}
inline bool Dtype_Parse(
    const ::std::string& name, Dtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Dtype>(
    Dtype_descriptor(), name, value);
}
// ===================================================================

class DiscreteSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.DiscreteSpace) */ {
 public:
  DiscreteSpace();
  virtual ~DiscreteSpace();

  DiscreteSpace(const DiscreteSpace& from);

  inline DiscreteSpace& operator=(const DiscreteSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscreteSpace(DiscreteSpace&& from) noexcept
    : DiscreteSpace() {
    *this = ::std::move(from);
  }

  inline DiscreteSpace& operator=(DiscreteSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscreteSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscreteSpace* internal_default_instance() {
    return reinterpret_cast<const DiscreteSpace*>(
               &_DiscreteSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DiscreteSpace* other);
  friend void swap(DiscreteSpace& a, DiscreteSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscreteSpace* New() const final {
    return CreateMaybeMessage<DiscreteSpace>(NULL);
  }

  DiscreteSpace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscreteSpace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscreteSpace& from);
  void MergeFrom(const DiscreteSpace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscreteSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 n = 1;
  void clear_n();
  static const int kNFieldNumber = 1;
  ::google::protobuf::int32 n() const;
  void set_n(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ns3opengym.DiscreteSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 n_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoxSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.BoxSpace) */ {
 public:
  BoxSpace();
  virtual ~BoxSpace();

  BoxSpace(const BoxSpace& from);

  inline BoxSpace& operator=(const BoxSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoxSpace(BoxSpace&& from) noexcept
    : BoxSpace() {
    *this = ::std::move(from);
  }

  inline BoxSpace& operator=(BoxSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoxSpace* internal_default_instance() {
    return reinterpret_cast<const BoxSpace*>(
               &_BoxSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BoxSpace* other);
  friend void swap(BoxSpace& a, BoxSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoxSpace* New() const final {
    return CreateMaybeMessage<BoxSpace>(NULL);
  }

  BoxSpace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoxSpace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoxSpace& from);
  void MergeFrom(const BoxSpace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 shape = 4;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 4;
  ::google::protobuf::int32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int32 value);
  void add_shape(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // float low = 1;
  void clear_low();
  static const int kLowFieldNumber = 1;
  float low() const;
  void set_low(float value);

  // float high = 2;
  void clear_high();
  static const int kHighFieldNumber = 2;
  float high() const;
  void set_high(float value);

  // .ns3opengym.Dtype dtype = 3;
  void clear_dtype();
  static const int kDtypeFieldNumber = 3;
  ::ns3opengym::Dtype dtype() const;
  void set_dtype(::ns3opengym::Dtype value);

  // @@protoc_insertion_point(class_scope:ns3opengym.BoxSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  mutable int _shape_cached_byte_size_;
  float low_;
  float high_;
  int dtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.RequestMsg) */ {
 public:
  RequestMsg();
  virtual ~RequestMsg();

  RequestMsg(const RequestMsg& from);

  inline RequestMsg& operator=(const RequestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestMsg(RequestMsg&& from) noexcept
    : RequestMsg() {
    *this = ::std::move(from);
  }

  inline RequestMsg& operator=(RequestMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestMsg* internal_default_instance() {
    return reinterpret_cast<const RequestMsg*>(
               &_RequestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RequestMsg* other);
  friend void swap(RequestMsg& a, RequestMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestMsg* New() const final {
    return CreateMaybeMessage<RequestMsg>(NULL);
  }

  RequestMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestMsg& from);
  void MergeFrom(const RequestMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any msg = 2;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_msg() const;
  public:
  const ::google::protobuf::Any& msg() const;
  ::google::protobuf::Any* release_msg();
  ::google::protobuf::Any* mutable_msg();
  void set_allocated_msg(::google::protobuf::Any* msg);

  // .ns3opengym.MsgType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ns3opengym::MsgType type() const;
  void set_type(::ns3opengym::MsgType value);

  // @@protoc_insertion_point(class_scope:ns3opengym.RequestMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* msg_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReplyMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.ReplyMsg) */ {
 public:
  ReplyMsg();
  virtual ~ReplyMsg();

  ReplyMsg(const ReplyMsg& from);

  inline ReplyMsg& operator=(const ReplyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplyMsg(ReplyMsg&& from) noexcept
    : ReplyMsg() {
    *this = ::std::move(from);
  }

  inline ReplyMsg& operator=(ReplyMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyMsg* internal_default_instance() {
    return reinterpret_cast<const ReplyMsg*>(
               &_ReplyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ReplyMsg* other);
  friend void swap(ReplyMsg& a, ReplyMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplyMsg* New() const final {
    return CreateMaybeMessage<ReplyMsg>(NULL);
  }

  ReplyMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReplyMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReplyMsg& from);
  void MergeFrom(const ReplyMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any msg = 2;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_msg() const;
  public:
  const ::google::protobuf::Any& msg() const;
  ::google::protobuf::Any* release_msg();
  ::google::protobuf::Any* mutable_msg();
  void set_allocated_msg(::google::protobuf::Any* msg);

  // .ns3opengym.MsgType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ns3opengym::MsgType type() const;
  void set_type(::ns3opengym::MsgType value);

  // @@protoc_insertion_point(class_scope:ns3opengym.ReplyMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* msg_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitializeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.InitializeRequest) */ {
 public:
  InitializeRequest();
  virtual ~InitializeRequest();

  InitializeRequest(const InitializeRequest& from);

  inline InitializeRequest& operator=(const InitializeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitializeRequest(InitializeRequest&& from) noexcept
    : InitializeRequest() {
    *this = ::std::move(from);
  }

  inline InitializeRequest& operator=(InitializeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeRequest* internal_default_instance() {
    return reinterpret_cast<const InitializeRequest*>(
               &_InitializeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InitializeRequest* other);
  friend void swap(InitializeRequest& a, InitializeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitializeRequest* New() const final {
    return CreateMaybeMessage<InitializeRequest>(NULL);
  }

  InitializeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitializeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitializeRequest& from);
  void MergeFrom(const InitializeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double timeStep = 1;
  void clear_timestep();
  static const int kTimeStepFieldNumber = 1;
  double timestep() const;
  void set_timestep(double value);

  // @@protoc_insertion_point(class_scope:ns3opengym.InitializeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double timestep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitializeReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.InitializeReply) */ {
 public:
  InitializeReply();
  virtual ~InitializeReply();

  InitializeReply(const InitializeReply& from);

  inline InitializeReply& operator=(const InitializeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitializeReply(InitializeReply&& from) noexcept
    : InitializeReply() {
    *this = ::std::move(from);
  }

  inline InitializeReply& operator=(InitializeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeReply* internal_default_instance() {
    return reinterpret_cast<const InitializeReply*>(
               &_InitializeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(InitializeReply* other);
  friend void swap(InitializeReply& a, InitializeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitializeReply* New() const final {
    return CreateMaybeMessage<InitializeReply>(NULL);
  }

  InitializeReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitializeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitializeReply& from);
  void MergeFrom(const InitializeReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool done = 1;
  void clear_done();
  static const int kDoneFieldNumber = 1;
  bool done() const;
  void set_done(bool value);

  // @@protoc_insertion_point(class_scope:ns3opengym.InitializeReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool done_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetActionSpaceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetActionSpaceRequest) */ {
 public:
  GetActionSpaceRequest();
  virtual ~GetActionSpaceRequest();

  GetActionSpaceRequest(const GetActionSpaceRequest& from);

  inline GetActionSpaceRequest& operator=(const GetActionSpaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetActionSpaceRequest(GetActionSpaceRequest&& from) noexcept
    : GetActionSpaceRequest() {
    *this = ::std::move(from);
  }

  inline GetActionSpaceRequest& operator=(GetActionSpaceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetActionSpaceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetActionSpaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetActionSpaceRequest*>(
               &_GetActionSpaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetActionSpaceRequest* other);
  friend void swap(GetActionSpaceRequest& a, GetActionSpaceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetActionSpaceRequest* New() const final {
    return CreateMaybeMessage<GetActionSpaceRequest>(NULL);
  }

  GetActionSpaceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetActionSpaceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetActionSpaceRequest& from);
  void MergeFrom(const GetActionSpaceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActionSpaceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetActionSpaceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetObservationSpaceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetObservationSpaceRequest) */ {
 public:
  GetObservationSpaceRequest();
  virtual ~GetObservationSpaceRequest();

  GetObservationSpaceRequest(const GetObservationSpaceRequest& from);

  inline GetObservationSpaceRequest& operator=(const GetObservationSpaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetObservationSpaceRequest(GetObservationSpaceRequest&& from) noexcept
    : GetObservationSpaceRequest() {
    *this = ::std::move(from);
  }

  inline GetObservationSpaceRequest& operator=(GetObservationSpaceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObservationSpaceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObservationSpaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetObservationSpaceRequest*>(
               &_GetObservationSpaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetObservationSpaceRequest* other);
  friend void swap(GetObservationSpaceRequest& a, GetObservationSpaceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetObservationSpaceRequest* New() const final {
    return CreateMaybeMessage<GetObservationSpaceRequest>(NULL);
  }

  GetObservationSpaceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetObservationSpaceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetObservationSpaceRequest& from);
  void MergeFrom(const GetObservationSpaceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObservationSpaceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetObservationSpaceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSpaceReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetSpaceReply) */ {
 public:
  GetSpaceReply();
  virtual ~GetSpaceReply();

  GetSpaceReply(const GetSpaceReply& from);

  inline GetSpaceReply& operator=(const GetSpaceReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSpaceReply(GetSpaceReply&& from) noexcept
    : GetSpaceReply() {
    *this = ::std::move(from);
  }

  inline GetSpaceReply& operator=(GetSpaceReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSpaceReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSpaceReply* internal_default_instance() {
    return reinterpret_cast<const GetSpaceReply*>(
               &_GetSpaceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetSpaceReply* other);
  friend void swap(GetSpaceReply& a, GetSpaceReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSpaceReply* New() const final {
    return CreateMaybeMessage<GetSpaceReply>(NULL);
  }

  GetSpaceReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSpaceReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSpaceReply& from);
  void MergeFrom(const GetSpaceReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSpaceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any space = 2;
  bool has_space() const;
  void clear_space();
  static const int kSpaceFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_space() const;
  public:
  const ::google::protobuf::Any& space() const;
  ::google::protobuf::Any* release_space();
  ::google::protobuf::Any* mutable_space();
  void set_allocated_space(::google::protobuf::Any* space);

  // .ns3opengym.SpaceType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ns3opengym::SpaceType type() const;
  void set_type(::ns3opengym::SpaceType value);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetSpaceReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* space_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetIsGameOverRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetIsGameOverRequest) */ {
 public:
  GetIsGameOverRequest();
  virtual ~GetIsGameOverRequest();

  GetIsGameOverRequest(const GetIsGameOverRequest& from);

  inline GetIsGameOverRequest& operator=(const GetIsGameOverRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetIsGameOverRequest(GetIsGameOverRequest&& from) noexcept
    : GetIsGameOverRequest() {
    *this = ::std::move(from);
  }

  inline GetIsGameOverRequest& operator=(GetIsGameOverRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIsGameOverRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetIsGameOverRequest* internal_default_instance() {
    return reinterpret_cast<const GetIsGameOverRequest*>(
               &_GetIsGameOverRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetIsGameOverRequest* other);
  friend void swap(GetIsGameOverRequest& a, GetIsGameOverRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetIsGameOverRequest* New() const final {
    return CreateMaybeMessage<GetIsGameOverRequest>(NULL);
  }

  GetIsGameOverRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetIsGameOverRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetIsGameOverRequest& from);
  void MergeFrom(const GetIsGameOverRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIsGameOverRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetIsGameOverRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetIsGameOverReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetIsGameOverReply) */ {
 public:
  GetIsGameOverReply();
  virtual ~GetIsGameOverReply();

  GetIsGameOverReply(const GetIsGameOverReply& from);

  inline GetIsGameOverReply& operator=(const GetIsGameOverReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetIsGameOverReply(GetIsGameOverReply&& from) noexcept
    : GetIsGameOverReply() {
    *this = ::std::move(from);
  }

  inline GetIsGameOverReply& operator=(GetIsGameOverReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIsGameOverReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetIsGameOverReply* internal_default_instance() {
    return reinterpret_cast<const GetIsGameOverReply*>(
               &_GetIsGameOverReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetIsGameOverReply* other);
  friend void swap(GetIsGameOverReply& a, GetIsGameOverReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetIsGameOverReply* New() const final {
    return CreateMaybeMessage<GetIsGameOverReply>(NULL);
  }

  GetIsGameOverReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetIsGameOverReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetIsGameOverReply& from);
  void MergeFrom(const GetIsGameOverReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIsGameOverReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool isGameOver = 1;
  void clear_isgameover();
  static const int kIsGameOverFieldNumber = 1;
  bool isgameover() const;
  void set_isgameover(bool value);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetIsGameOverReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool isgameover_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetObservationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetObservationRequest) */ {
 public:
  GetObservationRequest();
  virtual ~GetObservationRequest();

  GetObservationRequest(const GetObservationRequest& from);

  inline GetObservationRequest& operator=(const GetObservationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetObservationRequest(GetObservationRequest&& from) noexcept
    : GetObservationRequest() {
    *this = ::std::move(from);
  }

  inline GetObservationRequest& operator=(GetObservationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObservationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObservationRequest* internal_default_instance() {
    return reinterpret_cast<const GetObservationRequest*>(
               &_GetObservationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetObservationRequest* other);
  friend void swap(GetObservationRequest& a, GetObservationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetObservationRequest* New() const final {
    return CreateMaybeMessage<GetObservationRequest>(NULL);
  }

  GetObservationRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetObservationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetObservationRequest& from);
  void MergeFrom(const GetObservationRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObservationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetObservationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetObservationReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetObservationReply) */ {
 public:
  GetObservationReply();
  virtual ~GetObservationReply();

  GetObservationReply(const GetObservationReply& from);

  inline GetObservationReply& operator=(const GetObservationReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetObservationReply(GetObservationReply&& from) noexcept
    : GetObservationReply() {
    *this = ::std::move(from);
  }

  inline GetObservationReply& operator=(GetObservationReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObservationReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObservationReply* internal_default_instance() {
    return reinterpret_cast<const GetObservationReply*>(
               &_GetObservationReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetObservationReply* other);
  friend void swap(GetObservationReply& a, GetObservationReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetObservationReply* New() const final {
    return CreateMaybeMessage<GetObservationReply>(NULL);
  }

  GetObservationReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetObservationReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetObservationReply& from);
  void MergeFrom(const GetObservationReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObservationReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string observation = 1;
  void clear_observation();
  static const int kObservationFieldNumber = 1;
  const ::std::string& observation() const;
  void set_observation(const ::std::string& value);
  #if LANG_CXX11
  void set_observation(::std::string&& value);
  #endif
  void set_observation(const char* value);
  void set_observation(const char* value, size_t size);
  ::std::string* mutable_observation();
  ::std::string* release_observation();
  void set_allocated_observation(::std::string* observation);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetObservationReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr observation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRewardRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetRewardRequest) */ {
 public:
  GetRewardRequest();
  virtual ~GetRewardRequest();

  GetRewardRequest(const GetRewardRequest& from);

  inline GetRewardRequest& operator=(const GetRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRewardRequest(GetRewardRequest&& from) noexcept
    : GetRewardRequest() {
    *this = ::std::move(from);
  }

  inline GetRewardRequest& operator=(GetRewardRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRewardRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRewardRequest* internal_default_instance() {
    return reinterpret_cast<const GetRewardRequest*>(
               &_GetRewardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetRewardRequest* other);
  friend void swap(GetRewardRequest& a, GetRewardRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRewardRequest* New() const final {
    return CreateMaybeMessage<GetRewardRequest>(NULL);
  }

  GetRewardRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRewardRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRewardRequest& from);
  void MergeFrom(const GetRewardRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRewardRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetRewardRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRewardReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetRewardReply) */ {
 public:
  GetRewardReply();
  virtual ~GetRewardReply();

  GetRewardReply(const GetRewardReply& from);

  inline GetRewardReply& operator=(const GetRewardReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRewardReply(GetRewardReply&& from) noexcept
    : GetRewardReply() {
    *this = ::std::move(from);
  }

  inline GetRewardReply& operator=(GetRewardReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRewardReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRewardReply* internal_default_instance() {
    return reinterpret_cast<const GetRewardReply*>(
               &_GetRewardReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GetRewardReply* other);
  friend void swap(GetRewardReply& a, GetRewardReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRewardReply* New() const final {
    return CreateMaybeMessage<GetRewardReply>(NULL);
  }

  GetRewardReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRewardReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRewardReply& from);
  void MergeFrom(const GetRewardReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRewardReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float reward = 1;
  void clear_reward();
  static const int kRewardFieldNumber = 1;
  float reward() const;
  void set_reward(float value);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetRewardReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float reward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetActionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.SetActionRequest) */ {
 public:
  SetActionRequest();
  virtual ~SetActionRequest();

  SetActionRequest(const SetActionRequest& from);

  inline SetActionRequest& operator=(const SetActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetActionRequest(SetActionRequest&& from) noexcept
    : SetActionRequest() {
    *this = ::std::move(from);
  }

  inline SetActionRequest& operator=(SetActionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetActionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetActionRequest* internal_default_instance() {
    return reinterpret_cast<const SetActionRequest*>(
               &_SetActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SetActionRequest* other);
  friend void swap(SetActionRequest& a, SetActionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetActionRequest* New() const final {
    return CreateMaybeMessage<SetActionRequest>(NULL);
  }

  SetActionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetActionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetActionRequest& from);
  void MergeFrom(const SetActionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetActionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string action = 1;
  void clear_action();
  static const int kActionFieldNumber = 1;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  #if LANG_CXX11
  void set_action(::std::string&& value);
  #endif
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // @@protoc_insertion_point(class_scope:ns3opengym.SetActionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetActionReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.SetActionReply) */ {
 public:
  SetActionReply();
  virtual ~SetActionReply();

  SetActionReply(const SetActionReply& from);

  inline SetActionReply& operator=(const SetActionReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetActionReply(SetActionReply&& from) noexcept
    : SetActionReply() {
    *this = ::std::move(from);
  }

  inline SetActionReply& operator=(SetActionReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetActionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetActionReply* internal_default_instance() {
    return reinterpret_cast<const SetActionReply*>(
               &_SetActionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SetActionReply* other);
  friend void swap(SetActionReply& a, SetActionReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetActionReply* New() const final {
    return CreateMaybeMessage<SetActionReply>(NULL);
  }

  SetActionReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetActionReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetActionReply& from);
  void MergeFrom(const SetActionReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetActionReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool done = 1;
  void clear_done();
  static const int kDoneFieldNumber = 1;
  bool done() const;
  void set_done(bool value);

  // @@protoc_insertion_point(class_scope:ns3opengym.SetActionReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool done_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DiscreteSpace

// int32 n = 1;
inline void DiscreteSpace::clear_n() {
  n_ = 0;
}
inline ::google::protobuf::int32 DiscreteSpace::n() const {
  // @@protoc_insertion_point(field_get:ns3opengym.DiscreteSpace.n)
  return n_;
}
inline void DiscreteSpace::set_n(::google::protobuf::int32 value) {
  
  n_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.DiscreteSpace.n)
}

// -------------------------------------------------------------------

// BoxSpace

// float low = 1;
inline void BoxSpace::clear_low() {
  low_ = 0;
}
inline float BoxSpace::low() const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.low)
  return low_;
}
inline void BoxSpace::set_low(float value) {
  
  low_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.low)
}

// float high = 2;
inline void BoxSpace::clear_high() {
  high_ = 0;
}
inline float BoxSpace::high() const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.high)
  return high_;
}
inline void BoxSpace::set_high(float value) {
  
  high_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.high)
}

// .ns3opengym.Dtype dtype = 3;
inline void BoxSpace::clear_dtype() {
  dtype_ = 0;
}
inline ::ns3opengym::Dtype BoxSpace::dtype() const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.dtype)
  return static_cast< ::ns3opengym::Dtype >(dtype_);
}
inline void BoxSpace::set_dtype(::ns3opengym::Dtype value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.dtype)
}

// repeated int32 shape = 4;
inline int BoxSpace::shape_size() const {
  return shape_.size();
}
inline void BoxSpace::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 BoxSpace::shape(int index) const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.shape)
  return shape_.Get(index);
}
inline void BoxSpace::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.shape)
}
inline void BoxSpace::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:ns3opengym.BoxSpace.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BoxSpace::shape() const {
  // @@protoc_insertion_point(field_list:ns3opengym.BoxSpace.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BoxSpace::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:ns3opengym.BoxSpace.shape)
  return &shape_;
}

// -------------------------------------------------------------------

// RequestMsg

// .ns3opengym.MsgType type = 1;
inline void RequestMsg::clear_type() {
  type_ = 0;
}
inline ::ns3opengym::MsgType RequestMsg::type() const {
  // @@protoc_insertion_point(field_get:ns3opengym.RequestMsg.type)
  return static_cast< ::ns3opengym::MsgType >(type_);
}
inline void RequestMsg::set_type(::ns3opengym::MsgType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.RequestMsg.type)
}

// .google.protobuf.Any msg = 2;
inline bool RequestMsg::has_msg() const {
  return this != internal_default_instance() && msg_ != NULL;
}
inline const ::google::protobuf::Any& RequestMsg::_internal_msg() const {
  return *msg_;
}
inline const ::google::protobuf::Any& RequestMsg::msg() const {
  const ::google::protobuf::Any* p = msg_;
  // @@protoc_insertion_point(field_get:ns3opengym.RequestMsg.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* RequestMsg::release_msg() {
  // @@protoc_insertion_point(field_release:ns3opengym.RequestMsg.msg)
  
  ::google::protobuf::Any* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* RequestMsg::mutable_msg() {
  
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.RequestMsg.msg)
  return msg_;
}
inline void RequestMsg::set_allocated_msg(::google::protobuf::Any* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(msg_);
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    
  } else {
    
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.RequestMsg.msg)
}

// -------------------------------------------------------------------

// ReplyMsg

// .ns3opengym.MsgType type = 1;
inline void ReplyMsg::clear_type() {
  type_ = 0;
}
inline ::ns3opengym::MsgType ReplyMsg::type() const {
  // @@protoc_insertion_point(field_get:ns3opengym.ReplyMsg.type)
  return static_cast< ::ns3opengym::MsgType >(type_);
}
inline void ReplyMsg::set_type(::ns3opengym::MsgType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.ReplyMsg.type)
}

// .google.protobuf.Any msg = 2;
inline bool ReplyMsg::has_msg() const {
  return this != internal_default_instance() && msg_ != NULL;
}
inline const ::google::protobuf::Any& ReplyMsg::_internal_msg() const {
  return *msg_;
}
inline const ::google::protobuf::Any& ReplyMsg::msg() const {
  const ::google::protobuf::Any* p = msg_;
  // @@protoc_insertion_point(field_get:ns3opengym.ReplyMsg.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ReplyMsg::release_msg() {
  // @@protoc_insertion_point(field_release:ns3opengym.ReplyMsg.msg)
  
  ::google::protobuf::Any* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* ReplyMsg::mutable_msg() {
  
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.ReplyMsg.msg)
  return msg_;
}
inline void ReplyMsg::set_allocated_msg(::google::protobuf::Any* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(msg_);
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    
  } else {
    
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.ReplyMsg.msg)
}

// -------------------------------------------------------------------

// InitializeRequest

// double timeStep = 1;
inline void InitializeRequest::clear_timestep() {
  timestep_ = 0;
}
inline double InitializeRequest::timestep() const {
  // @@protoc_insertion_point(field_get:ns3opengym.InitializeRequest.timeStep)
  return timestep_;
}
inline void InitializeRequest::set_timestep(double value) {
  
  timestep_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.InitializeRequest.timeStep)
}

// -------------------------------------------------------------------

// InitializeReply

// bool done = 1;
inline void InitializeReply::clear_done() {
  done_ = false;
}
inline bool InitializeReply::done() const {
  // @@protoc_insertion_point(field_get:ns3opengym.InitializeReply.done)
  return done_;
}
inline void InitializeReply::set_done(bool value) {
  
  done_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.InitializeReply.done)
}

// -------------------------------------------------------------------

// GetActionSpaceRequest

// -------------------------------------------------------------------

// GetObservationSpaceRequest

// -------------------------------------------------------------------

// GetSpaceReply

// .ns3opengym.SpaceType type = 1;
inline void GetSpaceReply::clear_type() {
  type_ = 0;
}
inline ::ns3opengym::SpaceType GetSpaceReply::type() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetSpaceReply.type)
  return static_cast< ::ns3opengym::SpaceType >(type_);
}
inline void GetSpaceReply::set_type(::ns3opengym::SpaceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.GetSpaceReply.type)
}

// .google.protobuf.Any space = 2;
inline bool GetSpaceReply::has_space() const {
  return this != internal_default_instance() && space_ != NULL;
}
inline const ::google::protobuf::Any& GetSpaceReply::_internal_space() const {
  return *space_;
}
inline const ::google::protobuf::Any& GetSpaceReply::space() const {
  const ::google::protobuf::Any* p = space_;
  // @@protoc_insertion_point(field_get:ns3opengym.GetSpaceReply.space)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* GetSpaceReply::release_space() {
  // @@protoc_insertion_point(field_release:ns3opengym.GetSpaceReply.space)
  
  ::google::protobuf::Any* temp = space_;
  space_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* GetSpaceReply::mutable_space() {
  
  if (space_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    space_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.GetSpaceReply.space)
  return space_;
}
inline void GetSpaceReply::set_allocated_space(::google::protobuf::Any* space) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(space_);
  }
  if (space) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      space = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.GetSpaceReply.space)
}

// -------------------------------------------------------------------

// GetIsGameOverRequest

// -------------------------------------------------------------------

// GetIsGameOverReply

// bool isGameOver = 1;
inline void GetIsGameOverReply::clear_isgameover() {
  isgameover_ = false;
}
inline bool GetIsGameOverReply::isgameover() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetIsGameOverReply.isGameOver)
  return isgameover_;
}
inline void GetIsGameOverReply::set_isgameover(bool value) {
  
  isgameover_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.GetIsGameOverReply.isGameOver)
}

// -------------------------------------------------------------------

// GetObservationRequest

// -------------------------------------------------------------------

// GetObservationReply

// string observation = 1;
inline void GetObservationReply::clear_observation() {
  observation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetObservationReply::observation() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetObservationReply.observation)
  return observation_.GetNoArena();
}
inline void GetObservationReply::set_observation(const ::std::string& value) {
  
  observation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ns3opengym.GetObservationReply.observation)
}
#if LANG_CXX11
inline void GetObservationReply::set_observation(::std::string&& value) {
  
  observation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ns3opengym.GetObservationReply.observation)
}
#endif
inline void GetObservationReply::set_observation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  observation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ns3opengym.GetObservationReply.observation)
}
inline void GetObservationReply::set_observation(const char* value, size_t size) {
  
  observation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ns3opengym.GetObservationReply.observation)
}
inline ::std::string* GetObservationReply::mutable_observation() {
  
  // @@protoc_insertion_point(field_mutable:ns3opengym.GetObservationReply.observation)
  return observation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetObservationReply::release_observation() {
  // @@protoc_insertion_point(field_release:ns3opengym.GetObservationReply.observation)
  
  return observation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetObservationReply::set_allocated_observation(::std::string* observation) {
  if (observation != NULL) {
    
  } else {
    
  }
  observation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), observation);
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.GetObservationReply.observation)
}

// -------------------------------------------------------------------

// GetRewardRequest

// -------------------------------------------------------------------

// GetRewardReply

// float reward = 1;
inline void GetRewardReply::clear_reward() {
  reward_ = 0;
}
inline float GetRewardReply::reward() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetRewardReply.reward)
  return reward_;
}
inline void GetRewardReply::set_reward(float value) {
  
  reward_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.GetRewardReply.reward)
}

// -------------------------------------------------------------------

// SetActionRequest

// string action = 1;
inline void SetActionRequest::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetActionRequest::action() const {
  // @@protoc_insertion_point(field_get:ns3opengym.SetActionRequest.action)
  return action_.GetNoArena();
}
inline void SetActionRequest::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ns3opengym.SetActionRequest.action)
}
#if LANG_CXX11
inline void SetActionRequest::set_action(::std::string&& value) {
  
  action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ns3opengym.SetActionRequest.action)
}
#endif
inline void SetActionRequest::set_action(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ns3opengym.SetActionRequest.action)
}
inline void SetActionRequest::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ns3opengym.SetActionRequest.action)
}
inline ::std::string* SetActionRequest::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:ns3opengym.SetActionRequest.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetActionRequest::release_action() {
  // @@protoc_insertion_point(field_release:ns3opengym.SetActionRequest.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetActionRequest::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.SetActionRequest.action)
}

// -------------------------------------------------------------------

// SetActionReply

// bool done = 1;
inline void SetActionReply::clear_done() {
  done_ = false;
}
inline bool SetActionReply::done() const {
  // @@protoc_insertion_point(field_get:ns3opengym.SetActionReply.done)
  return done_;
}
inline void SetActionReply::set_done(bool value) {
  
  done_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.SetActionReply.done)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ns3opengym

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ns3opengym::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ns3opengym::MsgType>() {
  return ::ns3opengym::MsgType_descriptor();
}
template <> struct is_proto_enum< ::ns3opengym::SpaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ns3opengym::SpaceType>() {
  return ::ns3opengym::SpaceType_descriptor();
}
template <> struct is_proto_enum< ::ns3opengym::Dtype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ns3opengym::Dtype>() {
  return ::ns3opengym::Dtype_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2eproto
