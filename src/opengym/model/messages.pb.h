// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_INCLUDED_messages_2eproto
#define PROTOBUF_INCLUDED_messages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2eproto 

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[22];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2eproto
namespace ns3opengym {
class BoxDataContainer;
class BoxDataContainerDefaultTypeInternal;
extern BoxDataContainerDefaultTypeInternal _BoxDataContainer_default_instance_;
class BoxSpace;
class BoxSpaceDefaultTypeInternal;
extern BoxSpaceDefaultTypeInternal _BoxSpace_default_instance_;
class DataContainer;
class DataContainerDefaultTypeInternal;
extern DataContainerDefaultTypeInternal _DataContainer_default_instance_;
class DiscreteDataContainer;
class DiscreteDataContainerDefaultTypeInternal;
extern DiscreteDataContainerDefaultTypeInternal _DiscreteDataContainer_default_instance_;
class DiscreteSpace;
class DiscreteSpaceDefaultTypeInternal;
extern DiscreteSpaceDefaultTypeInternal _DiscreteSpace_default_instance_;
class GetActionSpaceRequest;
class GetActionSpaceRequestDefaultTypeInternal;
extern GetActionSpaceRequestDefaultTypeInternal _GetActionSpaceRequest_default_instance_;
class GetIsGameOverReply;
class GetIsGameOverReplyDefaultTypeInternal;
extern GetIsGameOverReplyDefaultTypeInternal _GetIsGameOverReply_default_instance_;
class GetIsGameOverRequest;
class GetIsGameOverRequestDefaultTypeInternal;
extern GetIsGameOverRequestDefaultTypeInternal _GetIsGameOverRequest_default_instance_;
class GetObservationReply;
class GetObservationReplyDefaultTypeInternal;
extern GetObservationReplyDefaultTypeInternal _GetObservationReply_default_instance_;
class GetObservationRequest;
class GetObservationRequestDefaultTypeInternal;
extern GetObservationRequestDefaultTypeInternal _GetObservationRequest_default_instance_;
class GetObservationSpaceRequest;
class GetObservationSpaceRequestDefaultTypeInternal;
extern GetObservationSpaceRequestDefaultTypeInternal _GetObservationSpaceRequest_default_instance_;
class GetRewardReply;
class GetRewardReplyDefaultTypeInternal;
extern GetRewardReplyDefaultTypeInternal _GetRewardReply_default_instance_;
class GetRewardRequest;
class GetRewardRequestDefaultTypeInternal;
extern GetRewardRequestDefaultTypeInternal _GetRewardRequest_default_instance_;
class GetSpaceReply;
class GetSpaceReplyDefaultTypeInternal;
extern GetSpaceReplyDefaultTypeInternal _GetSpaceReply_default_instance_;
class InitializeReply;
class InitializeReplyDefaultTypeInternal;
extern InitializeReplyDefaultTypeInternal _InitializeReply_default_instance_;
class InitializeRequest;
class InitializeRequestDefaultTypeInternal;
extern InitializeRequestDefaultTypeInternal _InitializeRequest_default_instance_;
class ReplyMsg;
class ReplyMsgDefaultTypeInternal;
extern ReplyMsgDefaultTypeInternal _ReplyMsg_default_instance_;
class RequestMsg;
class RequestMsgDefaultTypeInternal;
extern RequestMsgDefaultTypeInternal _RequestMsg_default_instance_;
class SetActionReply;
class SetActionReplyDefaultTypeInternal;
extern SetActionReplyDefaultTypeInternal _SetActionReply_default_instance_;
class SetActionRequest;
class SetActionRequestDefaultTypeInternal;
extern SetActionRequestDefaultTypeInternal _SetActionRequest_default_instance_;
class StopEnvReply;
class StopEnvReplyDefaultTypeInternal;
extern StopEnvReplyDefaultTypeInternal _StopEnvReply_default_instance_;
class StopEnvRequest;
class StopEnvRequestDefaultTypeInternal;
extern StopEnvRequestDefaultTypeInternal _StopEnvRequest_default_instance_;
}  // namespace ns3opengym
namespace google {
namespace protobuf {
template<> ::ns3opengym::BoxDataContainer* Arena::CreateMaybeMessage<::ns3opengym::BoxDataContainer>(Arena*);
template<> ::ns3opengym::BoxSpace* Arena::CreateMaybeMessage<::ns3opengym::BoxSpace>(Arena*);
template<> ::ns3opengym::DataContainer* Arena::CreateMaybeMessage<::ns3opengym::DataContainer>(Arena*);
template<> ::ns3opengym::DiscreteDataContainer* Arena::CreateMaybeMessage<::ns3opengym::DiscreteDataContainer>(Arena*);
template<> ::ns3opengym::DiscreteSpace* Arena::CreateMaybeMessage<::ns3opengym::DiscreteSpace>(Arena*);
template<> ::ns3opengym::GetActionSpaceRequest* Arena::CreateMaybeMessage<::ns3opengym::GetActionSpaceRequest>(Arena*);
template<> ::ns3opengym::GetIsGameOverReply* Arena::CreateMaybeMessage<::ns3opengym::GetIsGameOverReply>(Arena*);
template<> ::ns3opengym::GetIsGameOverRequest* Arena::CreateMaybeMessage<::ns3opengym::GetIsGameOverRequest>(Arena*);
template<> ::ns3opengym::GetObservationReply* Arena::CreateMaybeMessage<::ns3opengym::GetObservationReply>(Arena*);
template<> ::ns3opengym::GetObservationRequest* Arena::CreateMaybeMessage<::ns3opengym::GetObservationRequest>(Arena*);
template<> ::ns3opengym::GetObservationSpaceRequest* Arena::CreateMaybeMessage<::ns3opengym::GetObservationSpaceRequest>(Arena*);
template<> ::ns3opengym::GetRewardReply* Arena::CreateMaybeMessage<::ns3opengym::GetRewardReply>(Arena*);
template<> ::ns3opengym::GetRewardRequest* Arena::CreateMaybeMessage<::ns3opengym::GetRewardRequest>(Arena*);
template<> ::ns3opengym::GetSpaceReply* Arena::CreateMaybeMessage<::ns3opengym::GetSpaceReply>(Arena*);
template<> ::ns3opengym::InitializeReply* Arena::CreateMaybeMessage<::ns3opengym::InitializeReply>(Arena*);
template<> ::ns3opengym::InitializeRequest* Arena::CreateMaybeMessage<::ns3opengym::InitializeRequest>(Arena*);
template<> ::ns3opengym::ReplyMsg* Arena::CreateMaybeMessage<::ns3opengym::ReplyMsg>(Arena*);
template<> ::ns3opengym::RequestMsg* Arena::CreateMaybeMessage<::ns3opengym::RequestMsg>(Arena*);
template<> ::ns3opengym::SetActionReply* Arena::CreateMaybeMessage<::ns3opengym::SetActionReply>(Arena*);
template<> ::ns3opengym::SetActionRequest* Arena::CreateMaybeMessage<::ns3opengym::SetActionRequest>(Arena*);
template<> ::ns3opengym::StopEnvReply* Arena::CreateMaybeMessage<::ns3opengym::StopEnvReply>(Arena*);
template<> ::ns3opengym::StopEnvRequest* Arena::CreateMaybeMessage<::ns3opengym::StopEnvRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ns3opengym {

enum GetIsGameOverReply_Reason {
  GetIsGameOverReply_Reason_SimulationEnd = 0,
  GetIsGameOverReply_Reason_GameOver = 1,
  GetIsGameOverReply_Reason_GetIsGameOverReply_Reason_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GetIsGameOverReply_Reason_GetIsGameOverReply_Reason_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GetIsGameOverReply_Reason_IsValid(int value);
const GetIsGameOverReply_Reason GetIsGameOverReply_Reason_Reason_MIN = GetIsGameOverReply_Reason_SimulationEnd;
const GetIsGameOverReply_Reason GetIsGameOverReply_Reason_Reason_MAX = GetIsGameOverReply_Reason_GameOver;
const int GetIsGameOverReply_Reason_Reason_ARRAYSIZE = GetIsGameOverReply_Reason_Reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetIsGameOverReply_Reason_descriptor();
inline const ::std::string& GetIsGameOverReply_Reason_Name(GetIsGameOverReply_Reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetIsGameOverReply_Reason_descriptor(), value);
}
inline bool GetIsGameOverReply_Reason_Parse(
    const ::std::string& name, GetIsGameOverReply_Reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetIsGameOverReply_Reason>(
    GetIsGameOverReply_Reason_descriptor(), name, value);
}
enum MsgType {
  Unknown = 0,
  Init = 1,
  ActionSpace = 2,
  ObservationSpace = 3,
  IsGameOver = 4,
  Observation = 5,
  Reward = 6,
  Action = 7,
  StopEnv = 8,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = Unknown;
const MsgType MsgType_MAX = StopEnv;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum SpaceType {
  Discrete = 0,
  Box = 1,
  SpaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SpaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SpaceType_IsValid(int value);
const SpaceType SpaceType_MIN = Discrete;
const SpaceType SpaceType_MAX = Box;
const int SpaceType_ARRAYSIZE = SpaceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpaceType_descriptor();
inline const ::std::string& SpaceType_Name(SpaceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpaceType_descriptor(), value);
}
inline bool SpaceType_Parse(
    const ::std::string& name, SpaceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpaceType>(
    SpaceType_descriptor(), name, value);
}
enum Dtype {
  INT = 0,
  UINT = 1,
  FLOAT = 2,
  DOUBLE = 3,
  Dtype_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Dtype_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Dtype_IsValid(int value);
const Dtype Dtype_MIN = INT;
const Dtype Dtype_MAX = DOUBLE;
const int Dtype_ARRAYSIZE = Dtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* Dtype_descriptor();
inline const ::std::string& Dtype_Name(Dtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    Dtype_descriptor(), value);
}
inline bool Dtype_Parse(
    const ::std::string& name, Dtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Dtype>(
    Dtype_descriptor(), name, value);
}
// ===================================================================

class DiscreteSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.DiscreteSpace) */ {
 public:
  DiscreteSpace();
  virtual ~DiscreteSpace();

  DiscreteSpace(const DiscreteSpace& from);

  inline DiscreteSpace& operator=(const DiscreteSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscreteSpace(DiscreteSpace&& from) noexcept
    : DiscreteSpace() {
    *this = ::std::move(from);
  }

  inline DiscreteSpace& operator=(DiscreteSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscreteSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscreteSpace* internal_default_instance() {
    return reinterpret_cast<const DiscreteSpace*>(
               &_DiscreteSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DiscreteSpace* other);
  friend void swap(DiscreteSpace& a, DiscreteSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscreteSpace* New() const final {
    return CreateMaybeMessage<DiscreteSpace>(NULL);
  }

  DiscreteSpace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscreteSpace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscreteSpace& from);
  void MergeFrom(const DiscreteSpace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscreteSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 n = 1;
  void clear_n();
  static const int kNFieldNumber = 1;
  ::google::protobuf::int32 n() const;
  void set_n(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ns3opengym.DiscreteSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 n_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoxSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.BoxSpace) */ {
 public:
  BoxSpace();
  virtual ~BoxSpace();

  BoxSpace(const BoxSpace& from);

  inline BoxSpace& operator=(const BoxSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoxSpace(BoxSpace&& from) noexcept
    : BoxSpace() {
    *this = ::std::move(from);
  }

  inline BoxSpace& operator=(BoxSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoxSpace* internal_default_instance() {
    return reinterpret_cast<const BoxSpace*>(
               &_BoxSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BoxSpace* other);
  friend void swap(BoxSpace& a, BoxSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoxSpace* New() const final {
    return CreateMaybeMessage<BoxSpace>(NULL);
  }

  BoxSpace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoxSpace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoxSpace& from);
  void MergeFrom(const BoxSpace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 shape = 4;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 4;
  ::google::protobuf::uint32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::uint32 value);
  void add_shape(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_shape();

  // float low = 1;
  void clear_low();
  static const int kLowFieldNumber = 1;
  float low() const;
  void set_low(float value);

  // float high = 2;
  void clear_high();
  static const int kHighFieldNumber = 2;
  float high() const;
  void set_high(float value);

  // .ns3opengym.Dtype dtype = 3;
  void clear_dtype();
  static const int kDtypeFieldNumber = 3;
  ::ns3opengym::Dtype dtype() const;
  void set_dtype(::ns3opengym::Dtype value);

  // @@protoc_insertion_point(class_scope:ns3opengym.BoxSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > shape_;
  mutable int _shape_cached_byte_size_;
  float low_;
  float high_;
  int dtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.RequestMsg) */ {
 public:
  RequestMsg();
  virtual ~RequestMsg();

  RequestMsg(const RequestMsg& from);

  inline RequestMsg& operator=(const RequestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestMsg(RequestMsg&& from) noexcept
    : RequestMsg() {
    *this = ::std::move(from);
  }

  inline RequestMsg& operator=(RequestMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestMsg* internal_default_instance() {
    return reinterpret_cast<const RequestMsg*>(
               &_RequestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RequestMsg* other);
  friend void swap(RequestMsg& a, RequestMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestMsg* New() const final {
    return CreateMaybeMessage<RequestMsg>(NULL);
  }

  RequestMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestMsg& from);
  void MergeFrom(const RequestMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any msg = 2;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_msg() const;
  public:
  const ::google::protobuf::Any& msg() const;
  ::google::protobuf::Any* release_msg();
  ::google::protobuf::Any* mutable_msg();
  void set_allocated_msg(::google::protobuf::Any* msg);

  // .ns3opengym.MsgType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ns3opengym::MsgType type() const;
  void set_type(::ns3opengym::MsgType value);

  // @@protoc_insertion_point(class_scope:ns3opengym.RequestMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* msg_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReplyMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.ReplyMsg) */ {
 public:
  ReplyMsg();
  virtual ~ReplyMsg();

  ReplyMsg(const ReplyMsg& from);

  inline ReplyMsg& operator=(const ReplyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplyMsg(ReplyMsg&& from) noexcept
    : ReplyMsg() {
    *this = ::std::move(from);
  }

  inline ReplyMsg& operator=(ReplyMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyMsg* internal_default_instance() {
    return reinterpret_cast<const ReplyMsg*>(
               &_ReplyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ReplyMsg* other);
  friend void swap(ReplyMsg& a, ReplyMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplyMsg* New() const final {
    return CreateMaybeMessage<ReplyMsg>(NULL);
  }

  ReplyMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReplyMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReplyMsg& from);
  void MergeFrom(const ReplyMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any msg = 2;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_msg() const;
  public:
  const ::google::protobuf::Any& msg() const;
  ::google::protobuf::Any* release_msg();
  ::google::protobuf::Any* mutable_msg();
  void set_allocated_msg(::google::protobuf::Any* msg);

  // .ns3opengym.MsgType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ns3opengym::MsgType type() const;
  void set_type(::ns3opengym::MsgType value);

  // @@protoc_insertion_point(class_scope:ns3opengym.ReplyMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* msg_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitializeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.InitializeRequest) */ {
 public:
  InitializeRequest();
  virtual ~InitializeRequest();

  InitializeRequest(const InitializeRequest& from);

  inline InitializeRequest& operator=(const InitializeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitializeRequest(InitializeRequest&& from) noexcept
    : InitializeRequest() {
    *this = ::std::move(from);
  }

  inline InitializeRequest& operator=(InitializeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeRequest* internal_default_instance() {
    return reinterpret_cast<const InitializeRequest*>(
               &_InitializeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InitializeRequest* other);
  friend void swap(InitializeRequest& a, InitializeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitializeRequest* New() const final {
    return CreateMaybeMessage<InitializeRequest>(NULL);
  }

  InitializeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitializeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitializeRequest& from);
  void MergeFrom(const InitializeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double timeStep = 1;
  void clear_timestep();
  static const int kTimeStepFieldNumber = 1;
  double timestep() const;
  void set_timestep(double value);

  // @@protoc_insertion_point(class_scope:ns3opengym.InitializeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double timestep_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitializeReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.InitializeReply) */ {
 public:
  InitializeReply();
  virtual ~InitializeReply();

  InitializeReply(const InitializeReply& from);

  inline InitializeReply& operator=(const InitializeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitializeReply(InitializeReply&& from) noexcept
    : InitializeReply() {
    *this = ::std::move(from);
  }

  inline InitializeReply& operator=(InitializeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InitializeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitializeReply* internal_default_instance() {
    return reinterpret_cast<const InitializeReply*>(
               &_InitializeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(InitializeReply* other);
  friend void swap(InitializeReply& a, InitializeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitializeReply* New() const final {
    return CreateMaybeMessage<InitializeReply>(NULL);
  }

  InitializeReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitializeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitializeReply& from);
  void MergeFrom(const InitializeReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool done = 1;
  void clear_done();
  static const int kDoneFieldNumber = 1;
  bool done() const;
  void set_done(bool value);

  // @@protoc_insertion_point(class_scope:ns3opengym.InitializeReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool done_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetActionSpaceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetActionSpaceRequest) */ {
 public:
  GetActionSpaceRequest();
  virtual ~GetActionSpaceRequest();

  GetActionSpaceRequest(const GetActionSpaceRequest& from);

  inline GetActionSpaceRequest& operator=(const GetActionSpaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetActionSpaceRequest(GetActionSpaceRequest&& from) noexcept
    : GetActionSpaceRequest() {
    *this = ::std::move(from);
  }

  inline GetActionSpaceRequest& operator=(GetActionSpaceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetActionSpaceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetActionSpaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetActionSpaceRequest*>(
               &_GetActionSpaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetActionSpaceRequest* other);
  friend void swap(GetActionSpaceRequest& a, GetActionSpaceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetActionSpaceRequest* New() const final {
    return CreateMaybeMessage<GetActionSpaceRequest>(NULL);
  }

  GetActionSpaceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetActionSpaceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetActionSpaceRequest& from);
  void MergeFrom(const GetActionSpaceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetActionSpaceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetActionSpaceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetObservationSpaceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetObservationSpaceRequest) */ {
 public:
  GetObservationSpaceRequest();
  virtual ~GetObservationSpaceRequest();

  GetObservationSpaceRequest(const GetObservationSpaceRequest& from);

  inline GetObservationSpaceRequest& operator=(const GetObservationSpaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetObservationSpaceRequest(GetObservationSpaceRequest&& from) noexcept
    : GetObservationSpaceRequest() {
    *this = ::std::move(from);
  }

  inline GetObservationSpaceRequest& operator=(GetObservationSpaceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObservationSpaceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObservationSpaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetObservationSpaceRequest*>(
               &_GetObservationSpaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetObservationSpaceRequest* other);
  friend void swap(GetObservationSpaceRequest& a, GetObservationSpaceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetObservationSpaceRequest* New() const final {
    return CreateMaybeMessage<GetObservationSpaceRequest>(NULL);
  }

  GetObservationSpaceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetObservationSpaceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetObservationSpaceRequest& from);
  void MergeFrom(const GetObservationSpaceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObservationSpaceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetObservationSpaceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSpaceReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetSpaceReply) */ {
 public:
  GetSpaceReply();
  virtual ~GetSpaceReply();

  GetSpaceReply(const GetSpaceReply& from);

  inline GetSpaceReply& operator=(const GetSpaceReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSpaceReply(GetSpaceReply&& from) noexcept
    : GetSpaceReply() {
    *this = ::std::move(from);
  }

  inline GetSpaceReply& operator=(GetSpaceReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSpaceReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSpaceReply* internal_default_instance() {
    return reinterpret_cast<const GetSpaceReply*>(
               &_GetSpaceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetSpaceReply* other);
  friend void swap(GetSpaceReply& a, GetSpaceReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSpaceReply* New() const final {
    return CreateMaybeMessage<GetSpaceReply>(NULL);
  }

  GetSpaceReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSpaceReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSpaceReply& from);
  void MergeFrom(const GetSpaceReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSpaceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any space = 2;
  bool has_space() const;
  void clear_space();
  static const int kSpaceFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_space() const;
  public:
  const ::google::protobuf::Any& space() const;
  ::google::protobuf::Any* release_space();
  ::google::protobuf::Any* mutable_space();
  void set_allocated_space(::google::protobuf::Any* space);

  // .ns3opengym.SpaceType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ns3opengym::SpaceType type() const;
  void set_type(::ns3opengym::SpaceType value);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetSpaceReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* space_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetIsGameOverRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetIsGameOverRequest) */ {
 public:
  GetIsGameOverRequest();
  virtual ~GetIsGameOverRequest();

  GetIsGameOverRequest(const GetIsGameOverRequest& from);

  inline GetIsGameOverRequest& operator=(const GetIsGameOverRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetIsGameOverRequest(GetIsGameOverRequest&& from) noexcept
    : GetIsGameOverRequest() {
    *this = ::std::move(from);
  }

  inline GetIsGameOverRequest& operator=(GetIsGameOverRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIsGameOverRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetIsGameOverRequest* internal_default_instance() {
    return reinterpret_cast<const GetIsGameOverRequest*>(
               &_GetIsGameOverRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetIsGameOverRequest* other);
  friend void swap(GetIsGameOverRequest& a, GetIsGameOverRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetIsGameOverRequest* New() const final {
    return CreateMaybeMessage<GetIsGameOverRequest>(NULL);
  }

  GetIsGameOverRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetIsGameOverRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetIsGameOverRequest& from);
  void MergeFrom(const GetIsGameOverRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIsGameOverRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetIsGameOverRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetIsGameOverReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetIsGameOverReply) */ {
 public:
  GetIsGameOverReply();
  virtual ~GetIsGameOverReply();

  GetIsGameOverReply(const GetIsGameOverReply& from);

  inline GetIsGameOverReply& operator=(const GetIsGameOverReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetIsGameOverReply(GetIsGameOverReply&& from) noexcept
    : GetIsGameOverReply() {
    *this = ::std::move(from);
  }

  inline GetIsGameOverReply& operator=(GetIsGameOverReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIsGameOverReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetIsGameOverReply* internal_default_instance() {
    return reinterpret_cast<const GetIsGameOverReply*>(
               &_GetIsGameOverReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetIsGameOverReply* other);
  friend void swap(GetIsGameOverReply& a, GetIsGameOverReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetIsGameOverReply* New() const final {
    return CreateMaybeMessage<GetIsGameOverReply>(NULL);
  }

  GetIsGameOverReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetIsGameOverReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetIsGameOverReply& from);
  void MergeFrom(const GetIsGameOverReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIsGameOverReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetIsGameOverReply_Reason Reason;
  static const Reason SimulationEnd =
    GetIsGameOverReply_Reason_SimulationEnd;
  static const Reason GameOver =
    GetIsGameOverReply_Reason_GameOver;
  static inline bool Reason_IsValid(int value) {
    return GetIsGameOverReply_Reason_IsValid(value);
  }
  static const Reason Reason_MIN =
    GetIsGameOverReply_Reason_Reason_MIN;
  static const Reason Reason_MAX =
    GetIsGameOverReply_Reason_Reason_MAX;
  static const int Reason_ARRAYSIZE =
    GetIsGameOverReply_Reason_Reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Reason_descriptor() {
    return GetIsGameOverReply_Reason_descriptor();
  }
  static inline const ::std::string& Reason_Name(Reason value) {
    return GetIsGameOverReply_Reason_Name(value);
  }
  static inline bool Reason_Parse(const ::std::string& name,
      Reason* value) {
    return GetIsGameOverReply_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bool isGameOver = 1;
  void clear_isgameover();
  static const int kIsGameOverFieldNumber = 1;
  bool isgameover() const;
  void set_isgameover(bool value);

  // .ns3opengym.GetIsGameOverReply.Reason reason = 2;
  void clear_reason();
  static const int kReasonFieldNumber = 2;
  ::ns3opengym::GetIsGameOverReply_Reason reason() const;
  void set_reason(::ns3opengym::GetIsGameOverReply_Reason value);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetIsGameOverReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool isgameover_;
  int reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetObservationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetObservationRequest) */ {
 public:
  GetObservationRequest();
  virtual ~GetObservationRequest();

  GetObservationRequest(const GetObservationRequest& from);

  inline GetObservationRequest& operator=(const GetObservationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetObservationRequest(GetObservationRequest&& from) noexcept
    : GetObservationRequest() {
    *this = ::std::move(from);
  }

  inline GetObservationRequest& operator=(GetObservationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObservationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObservationRequest* internal_default_instance() {
    return reinterpret_cast<const GetObservationRequest*>(
               &_GetObservationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetObservationRequest* other);
  friend void swap(GetObservationRequest& a, GetObservationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetObservationRequest* New() const final {
    return CreateMaybeMessage<GetObservationRequest>(NULL);
  }

  GetObservationRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetObservationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetObservationRequest& from);
  void MergeFrom(const GetObservationRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObservationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetObservationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetObservationReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetObservationReply) */ {
 public:
  GetObservationReply();
  virtual ~GetObservationReply();

  GetObservationReply(const GetObservationReply& from);

  inline GetObservationReply& operator=(const GetObservationReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetObservationReply(GetObservationReply&& from) noexcept
    : GetObservationReply() {
    *this = ::std::move(from);
  }

  inline GetObservationReply& operator=(GetObservationReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObservationReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetObservationReply* internal_default_instance() {
    return reinterpret_cast<const GetObservationReply*>(
               &_GetObservationReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetObservationReply* other);
  friend void swap(GetObservationReply& a, GetObservationReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetObservationReply* New() const final {
    return CreateMaybeMessage<GetObservationReply>(NULL);
  }

  GetObservationReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetObservationReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetObservationReply& from);
  void MergeFrom(const GetObservationReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObservationReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ns3opengym.DataContainer container = 1;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 1;
  private:
  const ::ns3opengym::DataContainer& _internal_container() const;
  public:
  const ::ns3opengym::DataContainer& container() const;
  ::ns3opengym::DataContainer* release_container();
  ::ns3opengym::DataContainer* mutable_container();
  void set_allocated_container(::ns3opengym::DataContainer* container);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetObservationReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ns3opengym::DataContainer* container_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRewardRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetRewardRequest) */ {
 public:
  GetRewardRequest();
  virtual ~GetRewardRequest();

  GetRewardRequest(const GetRewardRequest& from);

  inline GetRewardRequest& operator=(const GetRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRewardRequest(GetRewardRequest&& from) noexcept
    : GetRewardRequest() {
    *this = ::std::move(from);
  }

  inline GetRewardRequest& operator=(GetRewardRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRewardRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRewardRequest* internal_default_instance() {
    return reinterpret_cast<const GetRewardRequest*>(
               &_GetRewardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetRewardRequest* other);
  friend void swap(GetRewardRequest& a, GetRewardRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRewardRequest* New() const final {
    return CreateMaybeMessage<GetRewardRequest>(NULL);
  }

  GetRewardRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRewardRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRewardRequest& from);
  void MergeFrom(const GetRewardRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRewardRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.GetRewardRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRewardReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.GetRewardReply) */ {
 public:
  GetRewardReply();
  virtual ~GetRewardReply();

  GetRewardReply(const GetRewardReply& from);

  inline GetRewardReply& operator=(const GetRewardReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRewardReply(GetRewardReply&& from) noexcept
    : GetRewardReply() {
    *this = ::std::move(from);
  }

  inline GetRewardReply& operator=(GetRewardReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRewardReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRewardReply* internal_default_instance() {
    return reinterpret_cast<const GetRewardReply*>(
               &_GetRewardReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GetRewardReply* other);
  friend void swap(GetRewardReply& a, GetRewardReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRewardReply* New() const final {
    return CreateMaybeMessage<GetRewardReply>(NULL);
  }

  GetRewardReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRewardReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRewardReply& from);
  void MergeFrom(const GetRewardReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRewardReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float reward = 1;
  void clear_reward();
  static const int kRewardFieldNumber = 1;
  float reward() const;
  void set_reward(float value);

  // @@protoc_insertion_point(class_scope:ns3opengym.GetRewardReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float reward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetActionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.SetActionRequest) */ {
 public:
  SetActionRequest();
  virtual ~SetActionRequest();

  SetActionRequest(const SetActionRequest& from);

  inline SetActionRequest& operator=(const SetActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetActionRequest(SetActionRequest&& from) noexcept
    : SetActionRequest() {
    *this = ::std::move(from);
  }

  inline SetActionRequest& operator=(SetActionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetActionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetActionRequest* internal_default_instance() {
    return reinterpret_cast<const SetActionRequest*>(
               &_SetActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SetActionRequest* other);
  friend void swap(SetActionRequest& a, SetActionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetActionRequest* New() const final {
    return CreateMaybeMessage<SetActionRequest>(NULL);
  }

  SetActionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetActionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetActionRequest& from);
  void MergeFrom(const SetActionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetActionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ns3opengym.DataContainer container = 1;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 1;
  private:
  const ::ns3opengym::DataContainer& _internal_container() const;
  public:
  const ::ns3opengym::DataContainer& container() const;
  ::ns3opengym::DataContainer* release_container();
  ::ns3opengym::DataContainer* mutable_container();
  void set_allocated_container(::ns3opengym::DataContainer* container);

  // @@protoc_insertion_point(class_scope:ns3opengym.SetActionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ns3opengym::DataContainer* container_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetActionReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.SetActionReply) */ {
 public:
  SetActionReply();
  virtual ~SetActionReply();

  SetActionReply(const SetActionReply& from);

  inline SetActionReply& operator=(const SetActionReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetActionReply(SetActionReply&& from) noexcept
    : SetActionReply() {
    *this = ::std::move(from);
  }

  inline SetActionReply& operator=(SetActionReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetActionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetActionReply* internal_default_instance() {
    return reinterpret_cast<const SetActionReply*>(
               &_SetActionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SetActionReply* other);
  friend void swap(SetActionReply& a, SetActionReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetActionReply* New() const final {
    return CreateMaybeMessage<SetActionReply>(NULL);
  }

  SetActionReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetActionReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetActionReply& from);
  void MergeFrom(const SetActionReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetActionReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool done = 1;
  void clear_done();
  static const int kDoneFieldNumber = 1;
  bool done() const;
  void set_done(bool value);

  // @@protoc_insertion_point(class_scope:ns3opengym.SetActionReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool done_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopEnvRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.StopEnvRequest) */ {
 public:
  StopEnvRequest();
  virtual ~StopEnvRequest();

  StopEnvRequest(const StopEnvRequest& from);

  inline StopEnvRequest& operator=(const StopEnvRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopEnvRequest(StopEnvRequest&& from) noexcept
    : StopEnvRequest() {
    *this = ::std::move(from);
  }

  inline StopEnvRequest& operator=(StopEnvRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopEnvRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopEnvRequest* internal_default_instance() {
    return reinterpret_cast<const StopEnvRequest*>(
               &_StopEnvRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(StopEnvRequest* other);
  friend void swap(StopEnvRequest& a, StopEnvRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopEnvRequest* New() const final {
    return CreateMaybeMessage<StopEnvRequest>(NULL);
  }

  StopEnvRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopEnvRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopEnvRequest& from);
  void MergeFrom(const StopEnvRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopEnvRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ns3opengym.StopEnvRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopEnvReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.StopEnvReply) */ {
 public:
  StopEnvReply();
  virtual ~StopEnvReply();

  StopEnvReply(const StopEnvReply& from);

  inline StopEnvReply& operator=(const StopEnvReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopEnvReply(StopEnvReply&& from) noexcept
    : StopEnvReply() {
    *this = ::std::move(from);
  }

  inline StopEnvReply& operator=(StopEnvReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopEnvReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopEnvReply* internal_default_instance() {
    return reinterpret_cast<const StopEnvReply*>(
               &_StopEnvReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(StopEnvReply* other);
  friend void swap(StopEnvReply& a, StopEnvReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopEnvReply* New() const final {
    return CreateMaybeMessage<StopEnvReply>(NULL);
  }

  StopEnvReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopEnvReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopEnvReply& from);
  void MergeFrom(const StopEnvReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopEnvReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool done = 1;
  void clear_done();
  static const int kDoneFieldNumber = 1;
  bool done() const;
  void set_done(bool value);

  // @@protoc_insertion_point(class_scope:ns3opengym.StopEnvReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool done_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.DataContainer) */ {
 public:
  DataContainer();
  virtual ~DataContainer();

  DataContainer(const DataContainer& from);

  inline DataContainer& operator=(const DataContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataContainer(DataContainer&& from) noexcept
    : DataContainer() {
    *this = ::std::move(from);
  }

  inline DataContainer& operator=(DataContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataContainer* internal_default_instance() {
    return reinterpret_cast<const DataContainer*>(
               &_DataContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(DataContainer* other);
  friend void swap(DataContainer& a, DataContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataContainer* New() const final {
    return CreateMaybeMessage<DataContainer>(NULL);
  }

  DataContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataContainer& from);
  void MergeFrom(const DataContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_data() const;
  public:
  const ::google::protobuf::Any& data() const;
  ::google::protobuf::Any* release_data();
  ::google::protobuf::Any* mutable_data();
  void set_allocated_data(::google::protobuf::Any* data);

  // .ns3opengym.SpaceType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ns3opengym::SpaceType type() const;
  void set_type(::ns3opengym::SpaceType value);

  // @@protoc_insertion_point(class_scope:ns3opengym.DataContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* data_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiscreteDataContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.DiscreteDataContainer) */ {
 public:
  DiscreteDataContainer();
  virtual ~DiscreteDataContainer();

  DiscreteDataContainer(const DiscreteDataContainer& from);

  inline DiscreteDataContainer& operator=(const DiscreteDataContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscreteDataContainer(DiscreteDataContainer&& from) noexcept
    : DiscreteDataContainer() {
    *this = ::std::move(from);
  }

  inline DiscreteDataContainer& operator=(DiscreteDataContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscreteDataContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscreteDataContainer* internal_default_instance() {
    return reinterpret_cast<const DiscreteDataContainer*>(
               &_DiscreteDataContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(DiscreteDataContainer* other);
  friend void swap(DiscreteDataContainer& a, DiscreteDataContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscreteDataContainer* New() const final {
    return CreateMaybeMessage<DiscreteDataContainer>(NULL);
  }

  DiscreteDataContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscreteDataContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscreteDataContainer& from);
  void MergeFrom(const DiscreteDataContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscreteDataContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::google::protobuf::int32 data() const;
  void set_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ns3opengym.DiscreteDataContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoxDataContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ns3opengym.BoxDataContainer) */ {
 public:
  BoxDataContainer();
  virtual ~BoxDataContainer();

  BoxDataContainer(const BoxDataContainer& from);

  inline BoxDataContainer& operator=(const BoxDataContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoxDataContainer(BoxDataContainer&& from) noexcept
    : BoxDataContainer() {
    *this = ::std::move(from);
  }

  inline BoxDataContainer& operator=(BoxDataContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxDataContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoxDataContainer* internal_default_instance() {
    return reinterpret_cast<const BoxDataContainer*>(
               &_BoxDataContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(BoxDataContainer* other);
  friend void swap(BoxDataContainer& a, BoxDataContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoxDataContainer* New() const final {
    return CreateMaybeMessage<BoxDataContainer>(NULL);
  }

  BoxDataContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoxDataContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoxDataContainer& from);
  void MergeFrom(const BoxDataContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxDataContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 shape = 2;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  ::google::protobuf::uint32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::uint32 value);
  void add_shape(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_shape();

  // repeated int32 intData = 3;
  int intdata_size() const;
  void clear_intdata();
  static const int kIntDataFieldNumber = 3;
  ::google::protobuf::int32 intdata(int index) const;
  void set_intdata(int index, ::google::protobuf::int32 value);
  void add_intdata(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intdata() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intdata();

  // repeated uint32 uintData = 4;
  int uintdata_size() const;
  void clear_uintdata();
  static const int kUintDataFieldNumber = 4;
  ::google::protobuf::uint32 uintdata(int index) const;
  void set_uintdata(int index, ::google::protobuf::uint32 value);
  void add_uintdata(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      uintdata() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_uintdata();

  // repeated float floatData = 5;
  int floatdata_size() const;
  void clear_floatdata();
  static const int kFloatDataFieldNumber = 5;
  float floatdata(int index) const;
  void set_floatdata(int index, float value);
  void add_floatdata(float value);
  const ::google::protobuf::RepeatedField< float >&
      floatdata() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_floatdata();

  // repeated double doubleData = 6;
  int doubledata_size() const;
  void clear_doubledata();
  static const int kDoubleDataFieldNumber = 6;
  double doubledata(int index) const;
  void set_doubledata(int index, double value);
  void add_doubledata(double value);
  const ::google::protobuf::RepeatedField< double >&
      doubledata() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_doubledata();

  // .ns3opengym.Dtype dtype = 1;
  void clear_dtype();
  static const int kDtypeFieldNumber = 1;
  ::ns3opengym::Dtype dtype() const;
  void set_dtype(::ns3opengym::Dtype value);

  // @@protoc_insertion_point(class_scope:ns3opengym.BoxDataContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > shape_;
  mutable int _shape_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intdata_;
  mutable int _intdata_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > uintdata_;
  mutable int _uintdata_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > floatdata_;
  mutable int _floatdata_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > doubledata_;
  mutable int _doubledata_cached_byte_size_;
  int dtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DiscreteSpace

// int32 n = 1;
inline void DiscreteSpace::clear_n() {
  n_ = 0;
}
inline ::google::protobuf::int32 DiscreteSpace::n() const {
  // @@protoc_insertion_point(field_get:ns3opengym.DiscreteSpace.n)
  return n_;
}
inline void DiscreteSpace::set_n(::google::protobuf::int32 value) {
  
  n_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.DiscreteSpace.n)
}

// -------------------------------------------------------------------

// BoxSpace

// float low = 1;
inline void BoxSpace::clear_low() {
  low_ = 0;
}
inline float BoxSpace::low() const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.low)
  return low_;
}
inline void BoxSpace::set_low(float value) {
  
  low_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.low)
}

// float high = 2;
inline void BoxSpace::clear_high() {
  high_ = 0;
}
inline float BoxSpace::high() const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.high)
  return high_;
}
inline void BoxSpace::set_high(float value) {
  
  high_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.high)
}

// .ns3opengym.Dtype dtype = 3;
inline void BoxSpace::clear_dtype() {
  dtype_ = 0;
}
inline ::ns3opengym::Dtype BoxSpace::dtype() const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.dtype)
  return static_cast< ::ns3opengym::Dtype >(dtype_);
}
inline void BoxSpace::set_dtype(::ns3opengym::Dtype value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.dtype)
}

// repeated uint32 shape = 4;
inline int BoxSpace::shape_size() const {
  return shape_.size();
}
inline void BoxSpace::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::uint32 BoxSpace::shape(int index) const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxSpace.shape)
  return shape_.Get(index);
}
inline void BoxSpace::set_shape(int index, ::google::protobuf::uint32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:ns3opengym.BoxSpace.shape)
}
inline void BoxSpace::add_shape(::google::protobuf::uint32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:ns3opengym.BoxSpace.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BoxSpace::shape() const {
  // @@protoc_insertion_point(field_list:ns3opengym.BoxSpace.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BoxSpace::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:ns3opengym.BoxSpace.shape)
  return &shape_;
}

// -------------------------------------------------------------------

// RequestMsg

// .ns3opengym.MsgType type = 1;
inline void RequestMsg::clear_type() {
  type_ = 0;
}
inline ::ns3opengym::MsgType RequestMsg::type() const {
  // @@protoc_insertion_point(field_get:ns3opengym.RequestMsg.type)
  return static_cast< ::ns3opengym::MsgType >(type_);
}
inline void RequestMsg::set_type(::ns3opengym::MsgType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.RequestMsg.type)
}

// .google.protobuf.Any msg = 2;
inline bool RequestMsg::has_msg() const {
  return this != internal_default_instance() && msg_ != NULL;
}
inline const ::google::protobuf::Any& RequestMsg::_internal_msg() const {
  return *msg_;
}
inline const ::google::protobuf::Any& RequestMsg::msg() const {
  const ::google::protobuf::Any* p = msg_;
  // @@protoc_insertion_point(field_get:ns3opengym.RequestMsg.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* RequestMsg::release_msg() {
  // @@protoc_insertion_point(field_release:ns3opengym.RequestMsg.msg)
  
  ::google::protobuf::Any* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* RequestMsg::mutable_msg() {
  
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.RequestMsg.msg)
  return msg_;
}
inline void RequestMsg::set_allocated_msg(::google::protobuf::Any* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(msg_);
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    
  } else {
    
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.RequestMsg.msg)
}

// -------------------------------------------------------------------

// ReplyMsg

// .ns3opengym.MsgType type = 1;
inline void ReplyMsg::clear_type() {
  type_ = 0;
}
inline ::ns3opengym::MsgType ReplyMsg::type() const {
  // @@protoc_insertion_point(field_get:ns3opengym.ReplyMsg.type)
  return static_cast< ::ns3opengym::MsgType >(type_);
}
inline void ReplyMsg::set_type(::ns3opengym::MsgType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.ReplyMsg.type)
}

// .google.protobuf.Any msg = 2;
inline bool ReplyMsg::has_msg() const {
  return this != internal_default_instance() && msg_ != NULL;
}
inline const ::google::protobuf::Any& ReplyMsg::_internal_msg() const {
  return *msg_;
}
inline const ::google::protobuf::Any& ReplyMsg::msg() const {
  const ::google::protobuf::Any* p = msg_;
  // @@protoc_insertion_point(field_get:ns3opengym.ReplyMsg.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ReplyMsg::release_msg() {
  // @@protoc_insertion_point(field_release:ns3opengym.ReplyMsg.msg)
  
  ::google::protobuf::Any* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* ReplyMsg::mutable_msg() {
  
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.ReplyMsg.msg)
  return msg_;
}
inline void ReplyMsg::set_allocated_msg(::google::protobuf::Any* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(msg_);
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    
  } else {
    
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.ReplyMsg.msg)
}

// -------------------------------------------------------------------

// InitializeRequest

// double timeStep = 1;
inline void InitializeRequest::clear_timestep() {
  timestep_ = 0;
}
inline double InitializeRequest::timestep() const {
  // @@protoc_insertion_point(field_get:ns3opengym.InitializeRequest.timeStep)
  return timestep_;
}
inline void InitializeRequest::set_timestep(double value) {
  
  timestep_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.InitializeRequest.timeStep)
}

// -------------------------------------------------------------------

// InitializeReply

// bool done = 1;
inline void InitializeReply::clear_done() {
  done_ = false;
}
inline bool InitializeReply::done() const {
  // @@protoc_insertion_point(field_get:ns3opengym.InitializeReply.done)
  return done_;
}
inline void InitializeReply::set_done(bool value) {
  
  done_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.InitializeReply.done)
}

// -------------------------------------------------------------------

// GetActionSpaceRequest

// -------------------------------------------------------------------

// GetObservationSpaceRequest

// -------------------------------------------------------------------

// GetSpaceReply

// .ns3opengym.SpaceType type = 1;
inline void GetSpaceReply::clear_type() {
  type_ = 0;
}
inline ::ns3opengym::SpaceType GetSpaceReply::type() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetSpaceReply.type)
  return static_cast< ::ns3opengym::SpaceType >(type_);
}
inline void GetSpaceReply::set_type(::ns3opengym::SpaceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.GetSpaceReply.type)
}

// .google.protobuf.Any space = 2;
inline bool GetSpaceReply::has_space() const {
  return this != internal_default_instance() && space_ != NULL;
}
inline const ::google::protobuf::Any& GetSpaceReply::_internal_space() const {
  return *space_;
}
inline const ::google::protobuf::Any& GetSpaceReply::space() const {
  const ::google::protobuf::Any* p = space_;
  // @@protoc_insertion_point(field_get:ns3opengym.GetSpaceReply.space)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* GetSpaceReply::release_space() {
  // @@protoc_insertion_point(field_release:ns3opengym.GetSpaceReply.space)
  
  ::google::protobuf::Any* temp = space_;
  space_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* GetSpaceReply::mutable_space() {
  
  if (space_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    space_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.GetSpaceReply.space)
  return space_;
}
inline void GetSpaceReply::set_allocated_space(::google::protobuf::Any* space) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(space_);
  }
  if (space) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      space = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    
  } else {
    
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.GetSpaceReply.space)
}

// -------------------------------------------------------------------

// GetIsGameOverRequest

// -------------------------------------------------------------------

// GetIsGameOverReply

// bool isGameOver = 1;
inline void GetIsGameOverReply::clear_isgameover() {
  isgameover_ = false;
}
inline bool GetIsGameOverReply::isgameover() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetIsGameOverReply.isGameOver)
  return isgameover_;
}
inline void GetIsGameOverReply::set_isgameover(bool value) {
  
  isgameover_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.GetIsGameOverReply.isGameOver)
}

// .ns3opengym.GetIsGameOverReply.Reason reason = 2;
inline void GetIsGameOverReply::clear_reason() {
  reason_ = 0;
}
inline ::ns3opengym::GetIsGameOverReply_Reason GetIsGameOverReply::reason() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetIsGameOverReply.reason)
  return static_cast< ::ns3opengym::GetIsGameOverReply_Reason >(reason_);
}
inline void GetIsGameOverReply::set_reason(::ns3opengym::GetIsGameOverReply_Reason value) {
  
  reason_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.GetIsGameOverReply.reason)
}

// -------------------------------------------------------------------

// GetObservationRequest

// -------------------------------------------------------------------

// GetObservationReply

// .ns3opengym.DataContainer container = 1;
inline bool GetObservationReply::has_container() const {
  return this != internal_default_instance() && container_ != NULL;
}
inline void GetObservationReply::clear_container() {
  if (GetArenaNoVirtual() == NULL && container_ != NULL) {
    delete container_;
  }
  container_ = NULL;
}
inline const ::ns3opengym::DataContainer& GetObservationReply::_internal_container() const {
  return *container_;
}
inline const ::ns3opengym::DataContainer& GetObservationReply::container() const {
  const ::ns3opengym::DataContainer* p = container_;
  // @@protoc_insertion_point(field_get:ns3opengym.GetObservationReply.container)
  return p != NULL ? *p : *reinterpret_cast<const ::ns3opengym::DataContainer*>(
      &::ns3opengym::_DataContainer_default_instance_);
}
inline ::ns3opengym::DataContainer* GetObservationReply::release_container() {
  // @@protoc_insertion_point(field_release:ns3opengym.GetObservationReply.container)
  
  ::ns3opengym::DataContainer* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::ns3opengym::DataContainer* GetObservationReply::mutable_container() {
  
  if (container_ == NULL) {
    auto* p = CreateMaybeMessage<::ns3opengym::DataContainer>(GetArenaNoVirtual());
    container_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.GetObservationReply.container)
  return container_;
}
inline void GetObservationReply::set_allocated_container(::ns3opengym::DataContainer* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_;
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.GetObservationReply.container)
}

// -------------------------------------------------------------------

// GetRewardRequest

// -------------------------------------------------------------------

// GetRewardReply

// float reward = 1;
inline void GetRewardReply::clear_reward() {
  reward_ = 0;
}
inline float GetRewardReply::reward() const {
  // @@protoc_insertion_point(field_get:ns3opengym.GetRewardReply.reward)
  return reward_;
}
inline void GetRewardReply::set_reward(float value) {
  
  reward_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.GetRewardReply.reward)
}

// -------------------------------------------------------------------

// SetActionRequest

// .ns3opengym.DataContainer container = 1;
inline bool SetActionRequest::has_container() const {
  return this != internal_default_instance() && container_ != NULL;
}
inline void SetActionRequest::clear_container() {
  if (GetArenaNoVirtual() == NULL && container_ != NULL) {
    delete container_;
  }
  container_ = NULL;
}
inline const ::ns3opengym::DataContainer& SetActionRequest::_internal_container() const {
  return *container_;
}
inline const ::ns3opengym::DataContainer& SetActionRequest::container() const {
  const ::ns3opengym::DataContainer* p = container_;
  // @@protoc_insertion_point(field_get:ns3opengym.SetActionRequest.container)
  return p != NULL ? *p : *reinterpret_cast<const ::ns3opengym::DataContainer*>(
      &::ns3opengym::_DataContainer_default_instance_);
}
inline ::ns3opengym::DataContainer* SetActionRequest::release_container() {
  // @@protoc_insertion_point(field_release:ns3opengym.SetActionRequest.container)
  
  ::ns3opengym::DataContainer* temp = container_;
  container_ = NULL;
  return temp;
}
inline ::ns3opengym::DataContainer* SetActionRequest::mutable_container() {
  
  if (container_ == NULL) {
    auto* p = CreateMaybeMessage<::ns3opengym::DataContainer>(GetArenaNoVirtual());
    container_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.SetActionRequest.container)
  return container_;
}
inline void SetActionRequest::set_allocated_container(::ns3opengym::DataContainer* container) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete container_;
  }
  if (container) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      container = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.SetActionRequest.container)
}

// -------------------------------------------------------------------

// SetActionReply

// bool done = 1;
inline void SetActionReply::clear_done() {
  done_ = false;
}
inline bool SetActionReply::done() const {
  // @@protoc_insertion_point(field_get:ns3opengym.SetActionReply.done)
  return done_;
}
inline void SetActionReply::set_done(bool value) {
  
  done_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.SetActionReply.done)
}

// -------------------------------------------------------------------

// StopEnvRequest

// -------------------------------------------------------------------

// StopEnvReply

// bool done = 1;
inline void StopEnvReply::clear_done() {
  done_ = false;
}
inline bool StopEnvReply::done() const {
  // @@protoc_insertion_point(field_get:ns3opengym.StopEnvReply.done)
  return done_;
}
inline void StopEnvReply::set_done(bool value) {
  
  done_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.StopEnvReply.done)
}

// -------------------------------------------------------------------

// DataContainer

// .ns3opengym.SpaceType type = 1;
inline void DataContainer::clear_type() {
  type_ = 0;
}
inline ::ns3opengym::SpaceType DataContainer::type() const {
  // @@protoc_insertion_point(field_get:ns3opengym.DataContainer.type)
  return static_cast< ::ns3opengym::SpaceType >(type_);
}
inline void DataContainer::set_type(::ns3opengym::SpaceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.DataContainer.type)
}

// .google.protobuf.Any data = 2;
inline bool DataContainer::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::google::protobuf::Any& DataContainer::_internal_data() const {
  return *data_;
}
inline const ::google::protobuf::Any& DataContainer::data() const {
  const ::google::protobuf::Any* p = data_;
  // @@protoc_insertion_point(field_get:ns3opengym.DataContainer.data)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* DataContainer::release_data() {
  // @@protoc_insertion_point(field_release:ns3opengym.DataContainer.data)
  
  ::google::protobuf::Any* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* DataContainer::mutable_data() {
  
  if (data_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ns3opengym.DataContainer.data)
  return data_;
}
inline void DataContainer::set_allocated_data(::google::protobuf::Any* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:ns3opengym.DataContainer.data)
}

// -------------------------------------------------------------------

// DiscreteDataContainer

// int32 data = 1;
inline void DiscreteDataContainer::clear_data() {
  data_ = 0;
}
inline ::google::protobuf::int32 DiscreteDataContainer::data() const {
  // @@protoc_insertion_point(field_get:ns3opengym.DiscreteDataContainer.data)
  return data_;
}
inline void DiscreteDataContainer::set_data(::google::protobuf::int32 value) {
  
  data_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.DiscreteDataContainer.data)
}

// -------------------------------------------------------------------

// BoxDataContainer

// .ns3opengym.Dtype dtype = 1;
inline void BoxDataContainer::clear_dtype() {
  dtype_ = 0;
}
inline ::ns3opengym::Dtype BoxDataContainer::dtype() const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxDataContainer.dtype)
  return static_cast< ::ns3opengym::Dtype >(dtype_);
}
inline void BoxDataContainer::set_dtype(::ns3opengym::Dtype value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:ns3opengym.BoxDataContainer.dtype)
}

// repeated uint32 shape = 2;
inline int BoxDataContainer::shape_size() const {
  return shape_.size();
}
inline void BoxDataContainer::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::uint32 BoxDataContainer::shape(int index) const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxDataContainer.shape)
  return shape_.Get(index);
}
inline void BoxDataContainer::set_shape(int index, ::google::protobuf::uint32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:ns3opengym.BoxDataContainer.shape)
}
inline void BoxDataContainer::add_shape(::google::protobuf::uint32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:ns3opengym.BoxDataContainer.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BoxDataContainer::shape() const {
  // @@protoc_insertion_point(field_list:ns3opengym.BoxDataContainer.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BoxDataContainer::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:ns3opengym.BoxDataContainer.shape)
  return &shape_;
}

// repeated int32 intData = 3;
inline int BoxDataContainer::intdata_size() const {
  return intdata_.size();
}
inline void BoxDataContainer::clear_intdata() {
  intdata_.Clear();
}
inline ::google::protobuf::int32 BoxDataContainer::intdata(int index) const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxDataContainer.intData)
  return intdata_.Get(index);
}
inline void BoxDataContainer::set_intdata(int index, ::google::protobuf::int32 value) {
  intdata_.Set(index, value);
  // @@protoc_insertion_point(field_set:ns3opengym.BoxDataContainer.intData)
}
inline void BoxDataContainer::add_intdata(::google::protobuf::int32 value) {
  intdata_.Add(value);
  // @@protoc_insertion_point(field_add:ns3opengym.BoxDataContainer.intData)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BoxDataContainer::intdata() const {
  // @@protoc_insertion_point(field_list:ns3opengym.BoxDataContainer.intData)
  return intdata_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BoxDataContainer::mutable_intdata() {
  // @@protoc_insertion_point(field_mutable_list:ns3opengym.BoxDataContainer.intData)
  return &intdata_;
}

// repeated uint32 uintData = 4;
inline int BoxDataContainer::uintdata_size() const {
  return uintdata_.size();
}
inline void BoxDataContainer::clear_uintdata() {
  uintdata_.Clear();
}
inline ::google::protobuf::uint32 BoxDataContainer::uintdata(int index) const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxDataContainer.uintData)
  return uintdata_.Get(index);
}
inline void BoxDataContainer::set_uintdata(int index, ::google::protobuf::uint32 value) {
  uintdata_.Set(index, value);
  // @@protoc_insertion_point(field_set:ns3opengym.BoxDataContainer.uintData)
}
inline void BoxDataContainer::add_uintdata(::google::protobuf::uint32 value) {
  uintdata_.Add(value);
  // @@protoc_insertion_point(field_add:ns3opengym.BoxDataContainer.uintData)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BoxDataContainer::uintdata() const {
  // @@protoc_insertion_point(field_list:ns3opengym.BoxDataContainer.uintData)
  return uintdata_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BoxDataContainer::mutable_uintdata() {
  // @@protoc_insertion_point(field_mutable_list:ns3opengym.BoxDataContainer.uintData)
  return &uintdata_;
}

// repeated float floatData = 5;
inline int BoxDataContainer::floatdata_size() const {
  return floatdata_.size();
}
inline void BoxDataContainer::clear_floatdata() {
  floatdata_.Clear();
}
inline float BoxDataContainer::floatdata(int index) const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxDataContainer.floatData)
  return floatdata_.Get(index);
}
inline void BoxDataContainer::set_floatdata(int index, float value) {
  floatdata_.Set(index, value);
  // @@protoc_insertion_point(field_set:ns3opengym.BoxDataContainer.floatData)
}
inline void BoxDataContainer::add_floatdata(float value) {
  floatdata_.Add(value);
  // @@protoc_insertion_point(field_add:ns3opengym.BoxDataContainer.floatData)
}
inline const ::google::protobuf::RepeatedField< float >&
BoxDataContainer::floatdata() const {
  // @@protoc_insertion_point(field_list:ns3opengym.BoxDataContainer.floatData)
  return floatdata_;
}
inline ::google::protobuf::RepeatedField< float >*
BoxDataContainer::mutable_floatdata() {
  // @@protoc_insertion_point(field_mutable_list:ns3opengym.BoxDataContainer.floatData)
  return &floatdata_;
}

// repeated double doubleData = 6;
inline int BoxDataContainer::doubledata_size() const {
  return doubledata_.size();
}
inline void BoxDataContainer::clear_doubledata() {
  doubledata_.Clear();
}
inline double BoxDataContainer::doubledata(int index) const {
  // @@protoc_insertion_point(field_get:ns3opengym.BoxDataContainer.doubleData)
  return doubledata_.Get(index);
}
inline void BoxDataContainer::set_doubledata(int index, double value) {
  doubledata_.Set(index, value);
  // @@protoc_insertion_point(field_set:ns3opengym.BoxDataContainer.doubleData)
}
inline void BoxDataContainer::add_doubledata(double value) {
  doubledata_.Add(value);
  // @@protoc_insertion_point(field_add:ns3opengym.BoxDataContainer.doubleData)
}
inline const ::google::protobuf::RepeatedField< double >&
BoxDataContainer::doubledata() const {
  // @@protoc_insertion_point(field_list:ns3opengym.BoxDataContainer.doubleData)
  return doubledata_;
}
inline ::google::protobuf::RepeatedField< double >*
BoxDataContainer::mutable_doubledata() {
  // @@protoc_insertion_point(field_mutable_list:ns3opengym.BoxDataContainer.doubleData)
  return &doubledata_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ns3opengym

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ns3opengym::GetIsGameOverReply_Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ns3opengym::GetIsGameOverReply_Reason>() {
  return ::ns3opengym::GetIsGameOverReply_Reason_descriptor();
}
template <> struct is_proto_enum< ::ns3opengym::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ns3opengym::MsgType>() {
  return ::ns3opengym::MsgType_descriptor();
}
template <> struct is_proto_enum< ::ns3opengym::SpaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ns3opengym::SpaceType>() {
  return ::ns3opengym::SpaceType_descriptor();
}
template <> struct is_proto_enum< ::ns3opengym::Dtype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ns3opengym::Dtype>() {
  return ::ns3opengym::Dtype_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2eproto
